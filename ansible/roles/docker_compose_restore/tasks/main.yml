---
- name: Tear down {{ stack_name }} Docker Compose stack
  community.docker.docker_compose_v2:
    project_src: /home/justin/{{ stack_name }}
    state: absent

- name: Read the {{ stack_name }} docker-compose.yml file
  slurp:
    src: /home/justin/{{ stack_name }}/docker-compose.yml
  register: docker_compose_file

- name: Parse the {{ stack_name }} docker-compose.yml file
  set_fact:
    docker_compose_content: "{{ docker_compose_file.content | b64decode | from_yaml }}"

- name: Extract {{ stack_name }} service names
  set_fact:
    service_names: "{{ docker_compose_content.services.keys() | list }}"

# - name: Display volume names (debugging purposes)
#   debug:
#     msg: "{{ service_names }}"

# - name: Print out the appropriate name
#   debug:
#     msg: "{{ stack_name }}_{{ item }}"
#   loop: "{{ service_names }}"

- name: Restore most recesnt Docker Volume backups for {{ stack_name }}
  block:

    # Check if there is a volume for this item active in the appropriate spot
    - name: Check if {{ stack_name }} volumes exist
      stat:
        path: "/home/justin/{{ stack_name }}/data/{{ item }}"
      loop: "{{ service_names }}"
      register: volume_exists
      loop_control:
        label: "{{ item }}"

    # Confirm there is at least backup file at the location
    - name: Ensure at least one backup file exists
      stat:
        path: "/home/justin/backups/docker/{{ stack_name }}/{{ item }}"
      loop: "{{ service_names }}"
      register: backup_files
      loop_control:
        label: "{{ item }}"

    # Find the newest working backup file
    - name: Find all backup volumes
      find:
        paths: "/home/justin/backups/docker/{{ stack_name }}/{{ item }}"
        patterns: "{{ item }}-backup-*"
        recurse: no
        file_type: directory
      when: backup_files
      register: backup_volumes
      loop: "{{ service_names }}"
      loop_control:
        label: "{{ item }}"

    - name: Initialize newest_backup_files
      set_fact:
        newest_backup_files: {}

    - name: Find the most recent backup for each volume
      set_fact:
        newest_backup_files: "{{ newest_backup_files | combine({ item.item: (item.files | sort(attribute='mtime', reverse=True) | first).path }) }}"
      loop: "{{ backup_volumes.results }}"
      when: item.files | length > 0
      loop_control:
        label: "{{ item.item }}"

    - name: Display newest backup files (debugging purposes)
      debug:
        msg: "{{ newest_backup_files.frontend | basename }}"

    # Fail Condition
    - name: Fail if no backup files are found
      fail:
        msg: "No backup files found for {{ stack_name }}"
      when: newest_backup_files is not defined or newest_backup_files == ""

    # - name: Display volume names (debugging purposes)
    #   debug:
    #     msg: "{{ volume_exists.results }}"

    # Remove existing volume
    - name: Remove existing volumes
      command: "rm -r /home/justin/{{ stack_name }}/data/{{ item.item }}"
      when: item.stat.exists
      loop: "{{ volume_exists.results }}"
      loop_control:
        label: "{{ item.item }}"

    # Copy it to the default spot and remane it as appropriate
    # Copy the newest backup files to the appropriate volume directory
    - name: Copy the newest backup files to /var/lib/docker/volumes
      copy:
        src: "{{ item.value }}"
        dest: "/home/justin/{{ stack_name }}/data"
        remote_src: yes
      with_dict: "{{ newest_backup_files }}"
      loop_control:
        label: "{{ item.key }}"

    - name: Rename the directory
      command: mv /home/justin/{{ stack_name }}/data/{{ item.value | basename }} /home/justin/{{ stack_name }}/data/{{ item.key }}
      args:
        creates: /home/justin/{{ stack_name }}/data/{{ item.key }}
      with_dict: "{{ newest_backup_files }}"
      loop_control:
        label: "{{ item.key }}"

- name: Deploy {{ stack_name }} Docker Compose stack
  community.docker.docker_compose_v2:
    project_src: /home/justin/{{ stack_name }}
    state: present
